<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

</body>
<script>

  // 【开心一刻】有这样一个场景，我在做退货操作，退货支持部分退功能，假设说我买了3件商品，我可以退1件或退2件或退3件；同时我还使用了100元优惠券；
  // 请写一个算法，同时满足以下两种情况：
  // 情况一：买了3个不同的商品各1件，如sku1 * 1，sku2 * 1，sku3 * 1，各自的原价是sku1 100元，sku2 200元，sku3 300元，我实际结算只支付了600-100=500元；
  // 情况二：买了1个相同的商品3件，如sku4 * 3，原价是sku4 200元，我实际结算也只支付了500元；

  // 那么请问，我退1件时，平台应该退给我多少钱，我退2件时退多少钱，退3件时退我多少钱。




  //总额 1100
  //优惠 100
  const handlePrice = (list, y, sort = 'desc') => {
    const result = []
    const scaleMap = new Map()
    // 所有商品的价格 不包含数量
    const totalPrice = list.reduce((total, item) => total += item.price, 0)
    list.forEach(d => {
      const scale = d.price / totalPrice
      scaleMap.set(d.skuCode, {
        scale: d.price / totalPrice,
        preferentialPrice: scale * y,
      })
    })

    list.forEach(item => {
      item.preferentialPrice =
        (scaleMap.get(item.skuCode).preferentialPrice / item.num).toFixed(2) - 0
    })

    list.forEach(d => {
      if (d.num === 1) {
        result.push({
          ...item,
          preferentialPrice: d.preferentialPrice,
          sfPrice: parseFloat((d.price - d.preferentialPrice).toFixed(2))
        })
      } else {
        [...new Array(d.num).fill(d).map((item, i) => {
          result.push({
            num: 1,
            skuCode: d.skuCode + '-' + (i + 1),
            price: d.price,
            preferentialPrice: item.preferentialPrice,
            parentSkuCode: d.skuCode,
            sfPrice: parseFloat((item.price - item.preferentialPrice).toFixed(2))
          })
        })]
      }
    });
    // 获取 每件商品 优惠均摊 金额
    const sharedAmount = result.map(d => d.preferentialPrice * d.num).reduce((a, b) => a + b)
    // 获取 取余
    const surplusAmount = parseFloat((y % sharedAmount).toFixed(2));
    // 倒叙 第一个 直接+ 上取模的参数
    console.log(result, surplusAmount, '')
    if (sort === 'asc') {
      result[0].sfPrice = parseFloat((result[0].sfPrice - surplusAmount).toFixed(2))
    }
    // 正叙 最后一个 直接+ 上取模的参数
    if (sort === 'desc') {
      result[result.length - 1].sfPrice = parseFloat((result[result.length - 1].sfPrice - surplusAmount).toFixed(2))
    }
    // 返回
    return result
  }

  const skuList2 = [
    {
      skuCode: "sku00001",
      price: 100,
      num: 2
    },
    {
      skuCode: "sku00002",
      price: 200,
      num: 2
    },
    {
      skuCode: "sku00003",
      price: 300,
      num: 3
    }
  ]
  // 优惠金额
  const y = 100
  const arr2 = handlePrice(skuList2, y)

  // 求和  
  const arrTotal2 = arr2.map(d => d.sfPrice)
  const arrTotal3 = arr2.map(d => d.preferentialPrice)
  console.log('处理后的数组2:', arr2, '求和2:', arrTotal2.reduce((a, b) => a + b), '优惠总额;', arrTotal3.reduce((a, b) => a + b));

</script>

</html>