<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

</body>

<script>
  function parse (template) {
    // 最终返回到 ast
    let root = null
    const result = []
    let i = 0;
    // 备份模版
    let html = template
    // 栈
    const stack = []
    // 便利 html 字符串
    while (html.trim()) {
      if (!result[i]) {
        result[i] = {}
      }
      const startIdx = html.indexOf('<')
      // 正常标签
      if (startIdx === 0) {
        // 结束标签
        if (html.indexOf('</') === 0) {
          parseEnd()
        } else {
          // 开始标签
          parseStartTag()
        }
        // 标签之前有文本
      } else if (startIdx > 0) {
        const nextStartIdx = html.indexOf('<')
        result[i].text = html.slice(0, nextStartIdx)
        if (stack.length) {
          processChars(html.slice(0, nextStartIdx))
          // 文本节点 移除
        }
        html = html.slice(nextStartIdx)
      } else {
        result[i].text = html
        html = ''
      }
      if (result[i].text && html.trim()) {
        i++
      }
    }


    return result.filter(item => JSON.stringify(item) !== '{}')
    // 匹配开始标签 <div id='app' >.... </div>
    function parseStartTag () {
      // <div title="11"></div>
      // 匹配开始标签的结束位置 <div title="11"
      const endIndex = html.indexOf('>')
      // 截取开始标签的内的所有内容 div title="11"
      const content = html.slice(1, endIndex)
      // 更新html 将content 从html 上截掉
      html = html.slice(endIndex + 1)
      // 标签   属性
      let tagName = '', attrStr = ''
      // 拿到第一个空格 的索引 div title="11"
      const fitstSpaceInd = content.indexOf(" ")
      // 不存在空格 就是没有属性
      if (fitstSpaceInd === -1) {
        // 直接赋值标签 div
        tagName = content
      } else {
        // 存在  赋值 属性和标签
        //  div
        tagName = content.slice(0, fitstSpaceInd)
        //  title="11"
        attrStr = content.slice(fitstSpaceInd + 1)
      }
      // 如果存在 属性 按照 空格分组
      const attrs = attrStr ? attrStr.split(' ') : []
      // 进一步处理属性 返回一个map
      const attrMap = parseAttrs(attrs)
      if (attrs.length) {
        result[i].attrs = attrMap
      }
      result[i].tagName = tagName
      // 生成ast
      const elementAst = generateAST(tagName, attrMap)
      if (!root) {
        root = elementAst
      }
      // 将 ast 对象 push 到栈中 当遇到他的结束标签 pop 出栈
      stack.push(elementAst)
      // 处理自闭和标签
      if (isUnaryTag(tagName)) {
        processElement()
      }
    }
    // 匹配开始结束
    function parseEnd () {
      // 将闭合标签 从html 字符串中移除
      html = html.slice(html.indexOf('>') + 1)
      // 进一步处理站定元素
      processElement()
    }

    // 处理标签的属性
    function processElement () {
      // 弹出栈顶元素
      const currentElement = stack.pop()
      currentElement.attr = {}
      // 进一把处 AST中的 rawAttr
      const { rawAttr } = currentElement
      const propertyArr = Object.keys(rawAttr)
      processSlotContent(currentElement)
      // 属性处理完成 让其和父节点产生关系
      if (stack.length) {
        stack.at(-1).children.push(currentElement)
        currentElement.parent = stack.at(-1)
      }
    }
    // 处理文本
    function processChars (text) {
      if (!text.trim()) return
      const textAST = {
        type: 3,
        text
      }
      // 处理文本是表达式  {{text}}
      if (text.match(/{{(.*)}}/)) {
        textAST.expression = RegExp.$1.trim()
      }
      stack.at(-1).children.push(textAST)
    }

    // ast
    function generateAST (tag, attrMap) {
      return {
        // 标签类型
        type: 1,
        // 标签名称
        tag,
        // 原始属性
        rawAttr: attrMap,
        // 子节点
        children: []
      }
    }

    // parseAttrs 解析attrs 返回map格式 []
    function parseAttrs (attrs) {
      const attrMap = {}
      for (let attr of attrs) {
        if (attr) {
          // = 截取 id=1 title=2 src=3
          const [attrName, attrValue] = attr.split('=')
          // 这里是为了处理 是否需要 data- 标签 如果不需要 放开这段
          // if (attrName.indexOf('-') !== -1) {
          //   attrMap[attrName.split('-').at(-1)] = attrValue.replace(/\"/g, '')
          // } else {
          attrMap[attrName] = attrValue.replace(/\"/g, '')
          // }
        }

      }

      return attrMap

    }
  }

  function isUnaryTag (tagName) {
    return ['input', 'img'].includes(tagName)
  }


  /**
   * @description: 处理插槽
   * @param {*} el
   * @return {*}
   * @author: alan
   */
  function processSlotContent (el) {
    if (el.tag === 'template') {
      const attrMap = el.rawAttr
      for (let k in attrMap) {
        if (k.match(/v-slot:(.*)/)) {
          // 说明有slot 标签
          const slotName = el.slotName = RegExp.$1
          el.scopeSlot = attrMap[`v-slot:${slotName}`]
          return
        }
      }
    }
  }
  // 输入
  let html1 = '我已阅读并接受相关<text data-type="1" data-name="肖明辉">条款和条件</text>和<text data-type="2">隐私政策</text><view>哈哈哈</view>。123131asdajda<div id="root">q1313</div>'
  // 期望输出
  //   [
  //     {
  //         "text": "我已阅读并接受相关"
  //     },
  //     {
  //         "attrs": {
  //             "data-type": "1",
  //             "data-name": "肖明辉"
  //         },
  //         "text": "条款和条件"
  //     },
  //     {
  //         "text": "和"
  //     },
  //     {
  //         "attrs": {
  //             "data-type": "2"
  //         },
  //         "text": "隐私政策"
  //     },
  //     {
  //         "text": "哈哈哈"
  //     }
  // ]

  // 仿照 vue 的思想 parse 进行 栈的 处理 匹配开始结束标签 进行处理
  class parser {
    constructor(reqParams = {}) {
      const { htmlStr, htmlRule = 'text', getAtter = 'type' } = reqParams
      // 不是字符串直接返回
      if (typeof htmlStr !== 'string') {
        throw new Error("请传递字符串")
      }
      return parse(htmlStr)
    }
  }

  const resultTemp1 = new parser({ htmlStr: html1 })
  console.log(resultTemp1)
</script>

</html>